#' A function to simulate a network
#'
#' Takes the output folder of the buildNetwork function and uses it to run a
#' network simulation. The simulation will run until a steady state has been
#' achieved unless otherwise specified. A steady state is considered to be
#' reached when all node values are considered to be equivelant to the previous
#' timestep for up to a threshold of decimal places.
#' @note this function can only be used if the output of the buildModel function
#'             was generated with the language argument set to "R".
#' @param folder the directory of the folder generated by the buildModel function.
#' @param delay the amount of delay to apply for delayed action of nodes. The
#'             default is set to 2.
#' @param tmax the maximum number of steps that you want to simulate for. Will
#'             terminate simulation when steady state is reached, unless tmax is
#'             reached first. If set to NA (the default), will simulate until
#'             stability is reached.
#' @param genotype default set to NA. Allows the user to provide a different genotypeDef
#'             data.frame from the one specified in the provided file.
#' @param startingValues default set to NA. Allows the user to provide a different
#'             nodestartDef data.frame from the one specified in the provided file.
#' @param steadyThreshold the number of decimal places to which node values must
#'             be equivalent to be considered a steady state. This threshold must
#'             be passed for all nodes.
#' @param exogenousSupply specifies if the value of a node (or nodes) is
#'               determined by an outside supply. In this case, the value of the
#'               node is supplied by the user and remains consistent throughout
#'               the course of the simulation. The default value for this
#'               argument is NULL. To specify nodes with an exogenous supply,
#'               provide a named vector containing the values of the nodes, with
#'               each vector member named after their respective node.
#' @export

simulateNetwork <- function(folder,
                            delay = 2,
                            tmax = NA,
                            genotype = NA,
                            startingValues = NA,
                            steadyThreshold = 4,
                            exogenousSupply = NULL) {
  # Checking if a meaningful delay has been provided
  if (delay == 1) {
    warning("You have selected a delay of 1 which is functionaly equivalent to
            no delay at all.")
  } else if (delay < 1) {
    warning("You have chosen an invalid delay. The delay has been reset to 2.")
    delay = 2
  }

  # sourcing data for simulation
  source(paste0(folder, "/nextStep.R"), local = T)

  if (any(is.na(genotype))) { # if a genotype has not been explicitly provided
    load(paste0(folder, "/genotypeDef.RData"))
  } else {
    genotypeDef <- genotype
  }

  if (any(is.na(startingValues))) { # if starting vals have not been explicitly provided
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    nodestartDef <- startingValues
  }

  if (nrow(genotypeDef) > 1 | nrow(nodestartDef) > 1) {
    stop("You have provided more than one condition. Consider using the setupSims function instead.")
  }

  # Run simulations
  if (is.na(tmax)) {
    rowChunk <- 100
  } else {
    rowChunk <- tmax
  }

  simDat <- nodestartDef # initiating data.frame
  simDat[1:(rowChunk + delay - 1), ] <- NA
  simDat[1:delay, ] <- nodestartDef

  t <- 2
  while (t <= nrow(simDat)) {
    row = t + delay - 1
    simDat[row, ] <- nextStep(dat = simDat[c((row-delay), (row-1)), ],
                              gen = genotypeDef[1,], delay = delay)

    # If any node has an exogenous supply
    if (!is.null(exogenousSupply)) {
      # overwriting the value calculated by nextStep
      simDat[row, names(exogenousSupply)] <- unname(exogenousSupply)
    }

    # If reached steady state, return simDat
    if(all(round(simDat[row,], steadyThreshold) == round(simDat[row - 1,], steadyThreshold))) {
      simDat = simDat[delay:row, ]
      return(simDat)
    }

    # If tmax has been reached (if there even is one), return simDat
    if (!is.na(tmax) & t == tmax) {
      simDat = simDat[delay:row, ]
      return(simDat)
    }

    # If any node has reached infinity
    if (any(is.infinite(unlist(simDat[row, ])))) {
      warning(paste0("The simulation was terminated at time ", t, " as the following node/s reached infinity: ",
                    paste(names(simDat)[is.infinite(unlist(simDat[row, ]))], collapse = ", "), "."))
      simDat = simDat[delay:row, ]
      return(simDat)
    }

    # If simDat has been filled without reaching steady state or tmax, add more rows
    if (row == nrow(simDat)) {
      simDat[(row + 1):(row + rowChunk), ] <- NA
    }

    t <- t + 1
  }
}

#' A wrapper function that allows you to run simulations of a network under
#' many different conditions.
#'
#' This function allows you to set up a variety of genotype and starting node
#' conditions to be simulated. It also allows you to test the outcome of
#' simulations under randomly assigned starting values. The function will make
#' sure to include one wild type condition (all genotypes set to 1) regardless
#' of if specified by the user.
#' @param folder the model folder generated by the buildModel function.
#' @param delay the amount of delay for any delayed transport. Default set to 2.
#' @param tmax the maximum number of timesteps for which to simulate.
#' @param exogenousSupply specifies if the value of a node (or nodes) is
#'               determined by an outside supply. In this case, the value of the
#'               node is supplied by the user and remains consistent throughout
#'               the course of the simulation. The default value for this
#'               argument is NULL. To specify nodes with an exogenous supply,
#'               provide a data frame with column names corresponding to the
#'               values of the nodes, with each vector member named after their
#'               respective node.
#' @importFrom stats runif
#' @export

setupSims <- function(folder,
                      delay = 2,
                      tmax = NA,
                      exogenousSupply = NULL) {
  # loading paramater values
  load(paste0(folder, "/genotypeDef.RData"))
  load(paste0(folder, "/nodestartDef.RData"))

  # Ensuring that the first row of genotypes contain a wildtype condition
  if (any(!apply(genotypeDef, 1, function(x) any(x != rep(1, ncol(genotypeDef)))))) {
    # if there are any rows in genotypeDef that contain a WT condition
    WT = which(!apply(genotypeDef, 1, function(x) any(x != rep(1, ncol(genotypeDef)))))
    if (WT != 1)
      # make sure that the first row is the WT condition
      genotypeDef <- genotypeDef[c(WT, c(1:nrow(genotypeDef))[-WT]), ]
  } else {
    # adding a row at the top with WT conditions
    genotypeDef[1:nrow(genotypeDef)+1, ] <- genotypeDef
    genotypeDef[1, ] <- 1
  }

  # Run simulations
  sims <- list()
  i = 1
  for (d in 1:nrow(nodestartDef)) {
    for (g in 1:nrow(genotypeDef)) {
      for (ex in 1:nrow(exogenousSupply)) {
        sims[[i]] <- list(scenario = list(genotype = genotypeDef[g, ],
                                        startingValues = nodestartDef[d, ],
                                        exogenousSupply = exogenousSupply[ex, ]),
                        simulation = simulateNetwork(folder = folder,
                                                     delay = delay,
                                                     tmax = tmax,
                                                     genotype = genotypeDef[g, ],
                                                     startingValues = nodestartDef[d, ],
                                                     exogenousSupply = exogenousSupply[ex, ]))
        i = i + 1
      }
    }
  }

  sims
}

#' A function to generate genotype screens.
#'
#' Will generate genotype screens which considers compartmental information,
#' and allows for the possibility of multiple types of mutation.
#' @param folder the model folder generated by the buildModel function.
#' @param numMutations how many concurrent mutations do you want to test.
#' @param mutationVal for each combination of mutated genes, what value should
#'        the genes take on? Default is set to 0 (knockout).
#' @param returnExcel default set to FALSE. If TRUE, will create an excel file
#'        and save it in the model folder. This file will contain a matrix
#'        showing all of the genotype combinations that have been screened. This
#'        can be used to record any existing experimental outcomes, to be
#'        compared against simulated outcomes later on.
#' @param graft default set to FALSE. Indicates if the user wants to
#'        consider differential expression between compartments.
#' @importFrom utils combn
#' @importFrom utils write.table
#' @export

genotypeScreen <- function(folder,
                           numMutations = 1,
                           mutationVal = 0,
                           returnExcel = FALSE,
                           graft = FALSE) {
  if (file.exists(paste0(folder, "/genotypeDef.RData"))) {
    load(paste0(folder, "/genotypeDef.RData"))
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    source(paste0(folder, "/genotypeDef.R"))
  }

  if (nrow(genotypeDef) > 1) {
    warning("Overwrote existing extended genotype screen.")
    genotypeDef <- genotypeDef[1, ]
  }

  comp = stringr::str_sub(colnames(genotypeDef), -1, -1)

  compartments <- vector("list", length = length(unique(comp)))
  names(compartments) <- unique(comp)

  for (i in 1:length(compartments)) {
    compartments[[i]] <- colnames(genotypeDef)[which(comp == unique(comp)[i])]
  }

  if (graft == F) {
    genotypeDef[2:((numCombn(ncol(genotypeDef)/length(compartments), numMutations)*length(mutationVal)) + 1), ] <- 1
  } else {
    genotypeDef[2:(numCombn(ncol(genotypeDef), numMutations)*length(mutationVal) + 1), ] <- 1
  }

  if (graft == F){
    splitGen <- unlist(strsplit(colnames(genotypeDef), "\\."))
    genType <- splitGen[(1:length(splitGen) %% 2) == T]
    gen <- unique(genType)

    combGen <- combn(gen, numMutations)
    for (i in 2:nrow(genotypeDef)) {
      genotypeDef[i, which(genType %in% combGen[, i - 1])] <- mutationVal
    }
  } else {
    combCol <- combn(ncol(genotypeDef), numMutations)
    for (i in 2:nrow(genotypeDef)) {
      genotypeDef[i, combCol[, i - 1]] <- mutationVal
    }
  }

  save(genotypeDef, file = paste0(folder, "/genotypeDef.Rdata"))
  return("File overwritten.")

  if (returnExcel == T) {
    sheets = vector("list", length = length(mutationVal))
    names(sheets) <- paste0("MutationVal=", mutationVal)

    spreadSheet <- matrix(NA, ncol = ncol(nodestartDef), nrow = nrow(genotypeDef))

    colnames(spreadSheet) <- colnames(nodestartDef)
    mutated <- genotypeDef != 1
    rows <- apply(mutated, 1, which)
    rowNames <- lapply(rows, names)
    rownames(spreadSheet) <- c("WT", sapply(rowNames, paste, collapse = ", ")[-1])

    write.table(spreadSheet,
                file = paste0(folder, "/experimentalData_mutationVal=",mutationVal,".csv"),
                sep = ",", row.names = T, col.names = NA)
  }
}


#' A function to generate a number of random starting point reassignments.
#'
#' Starting points will be generated for each node, pulled from a uniform
#' distribution. The existing starting values in the model folder will not
#' be overwritten.
#' @param folder the model folder generated by the buildModel function.
#' @param restarts the number of randomly assigned starting points that you
#'        want to test.
#' @param minVal default set to 0. The minimum value for a node to be.
#' @param maxVal default set to 2. The maximum value for a node to be.
#' @param static default set to FALSE. Determines if the final data.frame is
#'        saved as a .Rdata file. The default condition overwrites the
#'        nodestartDef.R file to define the new nodestartDef data.frame.
#' @export

randomStartScreen <- function(folder,
                              restarts,
                              minVal = 0,
                              maxVal = 2,
                              static = FALSE) {
  if (minVal < 0) {
    minVal = 0
    warning("Expression levels cannot be below 0. Have reassigned the minimum
            value to 0.")
  }

  if (file.exists(paste0(folder, "/nodestartDef.RData"))) {
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    source(paste0(folder, "/nodestartDef.R"))
  }

  nodestartDef[(nrow(nodestartDef) + 1):(nrow(nodestartDef) + restarts), ] <- round(runif(restarts*ncol(nodestartDef),
                                                            minVal, maxVal), 4)

  if (static == T) {
    save(nodestartDef, file = paste0(folder, "/nodestartDef.Rdata"))
  } else {
    cat("# defining storage data.frame and node initial values\n", file = file)
    cat("nodestartDef <- data.frame(\n", file = file, append = T)

    for (i in 1:ncol(nodestartDef)) {
      cat("\t'", colnames(nodestartDef)[i], "' = c(", paste(nodestartDef[,i], collapse = ", "),
          "),\n", sep="", file = file, append = T)
    }
  }
  cat(")", file = file, append = T)
}

#' A function to calculate the number of unique combinations of a vector
#' of length n of sample size r.
#'
#' @param n number of items in the vector.
#' @param r the size of the sample.

numCombn <- function(n, r) {
  if (r > n) {
    stop("Your sample size is greater than the length of the vector.")
  }

  factorial(n)/(factorial(r)*factorial(n-r))
}

#' A function to make sure that data.frames containing conditions to screen
#' are organised correctly. The wild-type condition is made to come first,
#' and any duplicate rows are removed.
#'
#' @param frame a data.frame
#' @importFrom prodlim row.match
minScreen <- function(frame) {
  # remove any row duplication
  if (any(duplicated(frame))) {
    frame <- frame[!duplicated(frame), ]
  }

  # if the first row is not WT
  if (!all(frame[1, ] == 1)) {
    WTrow <- row.match(rep(1, ncol(frame)), frame)

    if (is.na(WTrow)) {
      # add WT row in front
    } else {
      # switch WT row w 1st row
    }

  }
}



