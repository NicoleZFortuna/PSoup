#' A function to simulate a network
#'
#' Takes the output file of the buildNetwork function and uses it to run a
#' network simulation.
#' @param folder the model folder generated by the buildModel function.
#' @param delay the amount of delay to apply for delayed action of nodes. The
#'             default is set to 2.
#' @param tmax the maximum number of steps that you want to simulate for. If
#'             set to NA (the default), will simulate until stability is reached.
#' @param genotype default set to NA. Allows the user to provide a different gen
#'             data.frame from the one specified in the provided file.
#' @param startingValues default set to NA. Allows the user to provide a different
#'             dat data.frame from the one specified in the provided file.
#' @export

simulateNetwork <- function(folder, delay = 2, tmax = NA, genotype = NA, startingValues = NA) {
  if (delay == 1) {
    warning("You have selected a delay of 1 which is functionaly equivalent to
            no delay at all.")
  } else if (delay < 1) {
    warning("You have chosen an invalid delay. The delay has been reset to 2.")
    delay = 2
  }

  source(paste0(folder, "/genotypeDefinition.R"), local = T)
  source(paste0(folder, "/nodestartDefinition.R"), local = T)
  source(paste0(folder, "/nextStep.R"), local = T)

  if (!any(is.na(genotype))) {
    gen <- genotype
  }
  if (!any(is.na(startingValues))) {
    dat <- startingValues
  }

  simDat <- dat
  simDat[1:(tmax + delay - 1), ] <- NA
  simDat[1:delay, ] <- dat

  for (t in 2:tmax) {
    row = t + delay - 1
    simDat[row, ] <- nextStep(dat = simDat[c((row-delay),(row-1)), ],
                              gen = gen, delay = delay)
  }

  simDat = simDat[-c(1:(delay-1)), ]
  simDat
}

#' A wrapper function that allows you to run simulations of a network under
#' many differet conditions.
#'
#' This function allows you to set up a variety of genotype conditions to be
#' simulated. It also allows you to test the outcome of simulations under
#' randomly assigned starting values. The function will make sure to include
#' one wild type condition (all genotypes set to 1) regardless of if specified
#' by the user.
#' @param folder the model folder generated by the buildModel function.
#' @param delay the amount of delay for any delayed transport. Default set to 2.
#' @param tmax the maximum number of timesteps for which to simulate.
#' @importFrom stats runif
#' @export

setupSims <- function(folder, delay = 2, tmax = NA) {
  source(paste0(folder, "/genotypeDefinition.R"), local = T)
  source(paste0(folder, "/nodestartDefinition.R"), local = T)
  source(paste0(folder, "/nextStep.R"), local = T)

  if (any(!apply(gen, 1, function(x) any(x != rep(1, ncol(gen)))))) {
    # if there are any rows in gen that contain a WT condition
    WT = which(!apply(gen, 1, function(x) any(x != rep(1, ncol(dat)))))
    if (WT != 1)
      # make sure that the first row is the WT condition
      gen <- gen[c(WT, c(1:nrow(gen))[-WT]), ]
  } else {
    # adding a row at the top with WT conditions
    gen[1:nrow(gen)+1, ] <- gen
    gen[1, ] <- 1
  }

  sims <- list()
  i = 1
  for (d in 1:nrow(dat)) {
    for (g in 1:nrow(gen)) {
      sims[[i]] <- list(scenario = list(genotype = gen[g, ],
                                        startingValues = dat[d, ]),
                        simulation = simulateNetwork(folder = folder,
                                                     delay = delay,
                                                     tmax = tmax,
                                                     genotype = gen[g, ],
                                                     startingValues = dat[d, ]))
      i = i + 1
    }
  }

  sims
}

#' A function to generate genotype screenings.
#'
#' Will generate genetype screens which considers compartmental information,
#' allows for the possibility of multiple mutations.
#' @param folder the model folder generated by the buildModel function.
#' @param maxMutations the maximum number of concurrent mutations in a given
#'        compartment.
#' @param mutationVals for each combination of mutated genes, what value should
#'        the genes take on? Default is set to 0 (knockout). Can provide a
#'        vector for the variety of values that are wanted. Only one mutation
#'        value will be considered at a time.
#' @param returnExcel default set to FALSE. If TRUE, will create an excel file
#'        and save it in the model folder. This file will contain a matrix
#'        showing all of the genotype combinations that have been screened. This
#'        can be used to record any existing experimental outcomes, to be
#'        compared against simulated outcomes later on.
#' @param static default set to FALSE. Determines if the final data.frame is
#'        saved as a .Rdata file. The default condition overwrites the
#'        genotypeDefinition.R file to define the new gen data.frame.
#' @importFrom utils combn
#' @importFrom utils write.table
#' @export

genotypeScreen <- function(folder, maxMutations = 1, mutationVals = 0,
                           returnExcel = FALSE, static = FALSE) {
  source(paste0(folder, "/genotypeDefinition.R"))

  comp = stringr::str_sub(colnames(gen), -1, -1)

  compartments <- vector("list", length = length(unique(comp)))
  names(compartments) <- unique(comp)

  for (i in 1:length(compartments)) {
    compartments[[i]] <- colnames(gen)[which(comp == unique(comp)[i])]
  }

  if (maxMutations > 1) {
    for (i in 1:length(compartments)) {
      for (j in 2:maxMutations) {
        compartments[[i]] <- c(compartments[[i]],
                               apply(combn(compartments[[i]], j), 2, paste,
                                     collapse = "."))
      }
    }
  }

  getGens <- unname(droplevels(expand.grid(compartments$S, compartments$R), F))
  getGens <- apply(getGens, c(1,2), as.character)

  genotypes <- apply(getGens, 1, strsplit, ".", T)

  gen[2:(length(genotypes)*length(mutationVals) + 1), ] <- 1

  r = 1
  for (m in 1:length(mutationVals)) {
    for (g in 1:length(genotypes)) {
      r = r + 1
      gen[r, unlist(genotypes[[r - 1]])] <- mutationVals[m]
    }
  }

  if (static == T) {
    save(gen, file = paste0(folder, "/genotypeDefinition.Rdata"))
  } else {
    file = paste0(folder, "/genotypeDefinition.R")

    cat("# defining genotype values\n", file = file)
    cat("gen <- data.frame(\n", file = file, append = T)

    for (i in 1:ncol(gen)) {
      cat("\t'", colnames(gen)[i], "' = c(", paste(gen[,i], collapse = ", "),
          ")", sep="", file = file, append = T)
      if (i < ncol(gen)) {cat(",\n", file = file, append = T)}
    }
  }
  cat("\n)", file = file, append = T)

  if (returnExcel == TRUE) {
    sheets = vector("list", length = length(mutationVals))
    names(sheets) <- paste0("MutationVal=", mutationVals)

    for (i in 1:length(sheets)) {
      sheets[[i]] <- as.data.frame(array(NA, dim = sapply(compartments, length),
                           dimnames = compartments))

      if (i == 1) {
        cat(paste("Mutation Value", mutationVals[i]),
            file = paste0(folder, "/experimentalData.csv"))
      } else {
        cat(paste("\nMutation Value", mutationVals[i]),
            file = paste0(folder, "/experimentalData.csv"), append = T)
      }
      write.table(sheets[[1]], file = paste0(folder, "/experimentalData.csv"),
                  sep = ",", row.names = T, col.names = NA, append = T)
    }
  }
}

#' A function to generate a number of random starting point reassignments.
#'
#' Starting points will be generated for each node, pulled from a uniform
#' distribution. The existing starting values in the model folder will not
#' be overwritten.
#' @param folder the model folder generated by the buildModel function.
#' @param restarts the number of randomly assigned starting points that you
#'        want to test.
#' @param minVal default set to 0. The minimum value for a node to be.
#' @param maxVal default set to 2. The maximum value for a node to be.
#' @param static default set to FALSE. Determines if the final data.frame is
#'        saved as a .Rdata file. The default condition overwrites the
#'        nodestartDefinition.R file to define the new dat data.frame.
#' @export

randomStartScreen <- function(folder, restarts, minVal = 0, maxVal = 2, static = FALSE) {
  if (minVal < 0) {
    minVal = 0
    warning("Expression levels cannot be below 0. Have reassigned the minimum
            value to 0.")
  }

  file = paste0(folder, "/nodestartDefinition.R")

  source(file)

  dat[(nrow(dat) + 1):(nrow(dat) + restarts), ] <- round(runif(restarts*ncol(dat),
                                                            minVal, maxVal), 4)

  if (static == T) {
    save(dat, file = paste0(folder, "/nodestartDefinition.Rdata"))
  } else {
    cat("# defining storage data.frame and node initial values\n", file = file)
    cat("dat <- data.frame(\n", file = file, append = T)

    for (i in 1:ncol(dat)) {
      cat("\t'", colnames(dat)[i], "' = c(", paste(dat[,i], collapse = ", "),
          "),\n", sep="", file = file, append = T)
    }
  }
  cat(")", file = file, append = T)
}

