#' A function to simulate a network
#'
#' Takes the output folder of the buildNetwork function and uses it to run a
#' network simulation. The simulation will run until a steady state has been
#' achieved unless otherwise specified. A steady state is considered to be
#' reached when all node values are considered to be equivelant to the previous
#' timestep for up to a threshold of decimal places.
#' @param folder the directory of the folder generated by the buildModel function.
#' @param delay the amount of delay to apply for delayed action of nodes. The
#'             default is set to 2.
#' @param tmax the maximum number of steps that you want to simulate for. Will
#'             terminate simulation when steady state is reached, unless tmax is
#'             reached first. If set to NA (the default), will simulate until
#'             stability is reached.
#' @param genotype default set to NA. Allows the user to provide a different genotypeDef
#'             data.frame from the one specified in the provided file.
#' @param startingValues default set to NA. Allows the user to provide a different
#'             nodestartDef data.frame from the one specified in the provided file.
#' @param steadyThreshold the number of decimal places to which node values must
#'             be equivalent to be considered a steady state. This threshold must
#'             be passed for all nodes.
#' @export

simulateNetwork <- function(folder, delay = 2, tmax = NA, genotype = NA,
                            startingValues = NA, steadyThreshold = 4) {
  # Checking if a meaningful delay has been provided
  if (delay == 1) {
    warning("You have selected a delay of 1 which is functionaly equivalent to
            no delay at all.")
  } else if (delay < 1) {
    warning("You have chosen an invalid delay. The delay has been reset to 2.")
    delay = 2
  }

  # sourcing data for simulation
  source(paste0(folder, "/nextStep.R"), local = T)

  if (any(is.na(genotype))) { # if a genotype has not been explicitly provided
    if (file.exists(paste0(folder, "/genotypeDef.R"))) {
      source(paste0(folder, "/genotypeDef.R"), local = T)
    } else {
      load(paste0(folder, "/genotypeDef.RData"))
    }
  } else {
    genotypeDef <- genotype
  }

  if (any(is.na(startingValues))) { # if starting vals have not been explicitly provided
    if (file.exists(paste0(folder, "/nodestartDef.R"))) {
      source(paste0(folder, "/nodestartDef.R"), local = T)
    } else {
      load(paste0(folder, "/nodestartDef.RData"))
    }
  } else {
    nodestartDef <- startingValues
  }

  # Run simulations
  if (is.na(tmax)) {
    rowChunk <- 100
  } else {
    rowChunk <- tmax
  }

  simDat <- nodestartDef # initiating data.frame
  simDat[1:(rowChunk + delay - 1), ] <- NA
  simDat[1:delay, ] <- nodestartDef

  t <- 2
  while (t <= nrow(simDat)) {
    row = t + delay - 1
    simDat[row, ] <- nextStep(dat = simDat[c((row-delay), (row-1)), ],
                              gen = genotypeDef[1,], delay = delay)

    # If reached steady state, return simDat
    if(all(round(simDat[row,], steadyThreshold) == round(simDat[row - 1,], steadyThreshold))) {
      simDat = simDat[delay:row, ]
      return(simDat)
    }

    # If tmax has been reached (if there even is one), return simDat
    if (!is.na(tmax) & t == tmax) {
      simDat = simDat[delay:row, ]
      return(simDat)
    }

    # If simDat has been filled without reaching steady state or tmax, add more rows
    if (row == nrow(simDat)) {
      simDat[(row + 1):(row + rowChunk), ] <- NA
    }

    t <- t + 1
  }
}

#' A wrapper function that allows you to run simulations of a network under
#' many differet conditions.
#'
#' This function allows you to set up a variety of genotype conditions to be
#' simulated. It also allows you to test the outcome of simulations under
#' randomly assigned starting values. The function will make sure to include
#' one wild type condition (all genotypes set to 1) regardless of if specified
#' by the user.
#' @param folder the model folder generated by the buildModel function.
#' @param delay the amount of delay for any delayed transport. Default set to 2.
#' @param tmax the maximum number of timesteps for which to simulate.
#' @importFrom stats runif
#' @export

setupSims <- function(folder, delay = 2, tmax = NA) {
  # loading paramater values
  if (file.exists(paste0(folder, "/genotypeDef.R"))) {
    source(paste0(folder, "/genotypeDef.R"), local = T)
    source(paste0(folder, "/nodestartDef.R"), local = T)
  } else {
    load(paste0(folder, "/genotypeDef.RData"))
    load(paste0(folder, "/nodestartDef.RData"))
  }

  # Ensuring that the first row of genotypes contain a wildtype condition
  if (any(!apply(genotypeDef, 1, function(x) any(x != rep(1, ncol(genotypeDef)))))) {
    # if there are any rows in genotypeDef that contain a WT condition
    WT = which(!apply(genotypeDef, 1, function(x) any(x != rep(1, ncol(nodestartDef)))))
    if (WT != 1)
      # make sure that the first row is the WT condition
      genotypeDef <- genotypeDef[c(WT, c(1:nrow(genotypeDef))[-WT]), ]
  } else {
    # adding a row at the top with WT conditions
    genotypeDef[1:nrow(genotypeDef)+1, ] <- genotypeDef
    genotypeDef[1, ] <- 1
  }

  # Run simulations
  sims <- list()
  i = 1
  for (d in 1:nrow(nodestartDef)) {
    for (g in 1:nrow(genotypeDef)) {
      if (ncol(genotypeDef) > 1) {
        gen = genotypeDef[g, ]
      } else {
        gen = as.data.frame(genotypeDef[g,])
        colnames(gen) = colnames(genotypeDef)
        gen
      }

      sims[[i]] <- list(scenario = list(genotype = gen,
                                        startingValues = nodestartDef[d, ]),
                        simulation = simulateNetwork(folder = folder,
                                                     delay = delay,
                                                     tmax = tmax,
                                                     genotype = gen,
                                                     startingValues = nodestartDef[d, ]))
      i = i + 1
    }
  }

  sims
}

#' A function to generate genotype screenings.
#'
#' Will generate genotype screens which considers compartmental information,
#' allows for the possibility of multiple mutations.
#' @param folder the model folder generated by the buildModel function.
#' @param maxMutations the maximum number of concurrent mutations in a given
#'        compartment.
#' @param mutationVals for each combination of mutated genes, what value should
#'        the genes take on? Default is set to 0 (knockout). Can provide a
#'        vector for the variety of values that are wanted. Only one mutation
#'        value will be considered at a time.
#' @param returnExcel default set to FALSE. If TRUE, will create an excel file
#'        and save it in the model folder. This file will contain a matrix
#'        showing all of the genotype combinations that have been screened. This
#'        can be used to record any existing experimental outcomes, to be
#'        compared against simulated outcomes later on.
#' @param static default set to TRUE. Determines if the final data.frame is
#'        saved as a .Rdata file. The default condition overwrites the
#'        genotypeDef.R file to define the new genotypeDef data.frame.
#' @importFrom utils combn
#' @importFrom utils write.table
#' @export

genotypeScreen <- function(folder, maxMutations = 1, mutationVals = 0,
                           returnExcel = FALSE, static = TRUE) {
  if (file.exists(paste0(folder, "/genotypeDef.RData"))) {
    load(paste0(folder, "/genotypeDef.RData"))
  } else {
    source(paste0(folder, "/genotypeDef.R"))
  }

  comp = stringr::str_sub(colnames(genotypeDef), -1, -1)

  compartments <- vector("list", length = length(unique(comp)))
  names(compartments) <- unique(comp)

  for (i in 1:length(compartments)) {
    compartments[[i]] <- colnames(genotypeDef)[which(comp == unique(comp)[i])]
  }

  if (maxMutations > 1) {
    for (i in 1:length(compartments)) {
      for (j in 2:maxMutations) {
        compartments[[i]] <- c("WT", compartments[[i]],
                               apply(combn(compartments[[i]], j), 2, paste,
                                     collapse = "."))
      }
    }
  }

  getGens <- unname(droplevels(expand.grid(compartments$S, compartments$R), F))
  getGens <- apply(getGens, c(1,2), as.character)

  genotypes <- apply(getGens, 1, strsplit, ".", T)

  genotypeDef[2:(length(genotypes)*length(mutationVals) + 1), ] <- 1

  r = 1
  for (m in 1:length(mutationVals)) {
    for (g in 1:length(genotypes)) {
      r = r + 1
      genes <- unlist(genotypes[[r - 1]])
      if (any(genes != "WT")) {
        genes <- genes[genes != "WT"]
        genotypeDef[r, genes] <- mutationVals[m]
      }
    }
  }

  if   (static == T) {
    save(genotypeDef, file = paste0(folder, "/genotypeDef.Rdata"))
  } else {
    file = paste0(folder, "/genotypeDef.R")

    cat("# defining genotype values\n", file = file)
    cat("genotypeDef <- data.frame(\n", file = file, append = T)

    for (i in 1:ncol(genotypeDef)) {
      cat("\t'", colnames(genotypeDef)[i], "' = c(", paste(genotypeDef[,i], collapse = ", "),
          ")", sep="", file = file, append = T)
      if (i < ncol(genotypeDef)) {cat(",\n", file = file, append = T)}
    }
    cat("\n)", file = file, append = T)
  }

  if (returnExcel == TRUE) {
    sheets = vector("list", length = length(mutationVals))
    names(sheets) <- paste0("MutationVal=", mutationVals)

    for (i in 1:length(sheets)) {
      sheets[[i]] <- as.data.frame(array(NA, dim = sapply(compartments, length),
                           dimnames = compartments))

      if (i == 1) {
        cat(paste("Mutation Value", mutationVals[i]),
            file = paste0(folder, "/experimentalData.csv"))
      } else {
        cat(paste("\nMutation Value", mutationVals[i]),
            file = paste0(folder, "/experimentalData.csv"), append = T)
      }
      write.table(sheets[[1]], file = paste0(folder, "/experimentalData.csv"),
                  sep = ",", row.names = T, col.names = NA, append = T)
    }
  }
}

#' A function to generate a number of random starting point reassignments.
#'
#' Starting points will be generated for each node, pulled from a uniform
#' distribution. The existing starting values in the model folder will not
#' be overwritten.
#' @param folder the model folder generated by the buildModel function.
#' @param restarts the number of randomly assigned starting points that you
#'        want to test.
#' @param minVal default set to 0. The minimum value for a node to be.
#' @param maxVal default set to 2. The maximum value for a node to be.
#' @param static default set to FALSE. Determines if the final data.frame is
#'        saved as a .Rdata file. The default condition overwrites the
#'        nodestartDef.R file to define the new nodestartDef data.frame.
#' @export

randomStartScreen <- function(folder, restarts, minVal = 0, maxVal = 2, static = FALSE) {
  if (minVal < 0) {
    minVal = 0
    warning("Expression levels cannot be below 0. Have reassigned the minimum
            value to 0.")
  }

  if (file.exists(paste0(folder, "/nodestartDef.RData"))) {
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    source(paste0(folder, "/nodestartDef.R"))
  }

  nodestartDef[(nrow(nodestartDef) + 1):(nrow(nodestartDef) + restarts), ] <- round(runif(restarts*ncol(nodestartDef),
                                                            minVal, maxVal), 4)

  if (static == T) {
    save(nodestartDef, file = paste0(folder, "/nodestartDef.Rdata"))
  } else {
    cat("# defining storage data.frame and node initial values\n", file = file)
    cat("nodestartDef <- data.frame(\n", file = file, append = T)

    for (i in 1:ncol(nodestartDef)) {
      cat("\t'", colnames(nodestartDef)[i], "' = c(", paste(nodestartDef[,i], collapse = ", "),
          "),\n", sep="", file = file, append = T)
    }
  }
  cat(")", file = file, append = T)
}

