#' A function to simulate a network
#'
#' Takes the output folder of the buildNetwork function and uses it to run a
#' network simulation. The simulation will run until a steady state has been
#' achieved unless otherwise specified. A steady state is considered to be
#' reached when all node values are considered to be equivelant to the previous
#' timestep for up to a threshold of decimal places.
#' @note this function can only be used if the output of the buildModel function
#'             was generated with the language argument set to "R".
#' @param folder the directory of the folder generated by the buildModel function.
#' @param delay the amount of delay to apply for delayed action of nodes. The
#'             default is set to 2.
#' @param tmax the maximum number of steps that you want to simulate for. Will
#'             terminate simulation when steady state is reached, unless tmax is
#'             reached first. If set to NA (the default), will simulate until
#'             stability is reached.
#' @param genotype default set to NA. Allows the user to provide a different genotypeDef
#'             data.frame from the one specified in the provided file.
#' @param startingValues default set to NA. Allows the user to provide a different
#'             nodestartDef data.frame from the one specified in the provided file.
#' @param steadyThreshold the number of decimal places to which node values must
#'             be equivalent to be considered a steady state. This threshold must
#'             be passed for all nodes.
#' @param exogenousSupply specifies if the value of a node (or nodes) is
#'               determined by an outside supply. In this case, the value of the
#'               node is supplied by the user and remains consistent throughout
#'               the course of the simulation. The default value for this
#'               argument is NULL. To specify nodes with an exogenous supply,
#'               provide a named vector containing the values of the nodes, with
#'               each vector member named after their respective node.
#' @param robustnessTest logical. Defaults to FALSE. Specifies if the nextStep
#'               function being used is part of a network robustness check.
#' @param altTopologyName default to NULL. If robustnessTest = T, this argument
#'               allows the user to keep the generated alternate nextStep function
#'               with a specific name. If no name is provided, the alternate
#'               nextStep functions will be names nextStepAlt.R.
#' @export

simulateNetwork <- function(folder,
                            delay = 2,
                            tmax = NA,
                            genotype = NA,
                            startingValues = NA,
                            steadyThreshold = 4,
                            exogenousSupply = NULL,
                            robustnessTest = F,
                            altTopologyName = NULL) {
  # Checking if a meaningful delay has been provided
  if (delay == 1) {
    warning("You have selected a delay of 1 which is functionaly equivalent to
            no delay at all.")
  } else if (delay < 1) {
    warning("You have chosen an invalid delay. The delay has been reset to 2.")
    delay = 2
  }

  # sourcing data for simulation
  if (robustnessTest == F) {
    source(paste0(folder, "/nextStep.R"), local = T)
  } else {
    source(paste0(folder, "/", altTopologyName, "_nextStepAlt.R"))
  }


  if (any(is.na(genotype))) { # if a genotype has not been explicitly provided
    load(paste0(folder, "/genotypeDef.RData"))
  } else {
    genotypeDef <- genotype
  }

  if (any(is.na(startingValues))) { # if starting vals have not been explicitly provided
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    nodestartDef <- startingValues
  }

  if (nrow(genotypeDef) > 1 | nrow(nodestartDef) > 1) {
    stop("You have provided more than one condition. Consider using the setupSims function instead.")
  }

  # Run simulations
  if (is.na(tmax)) {
    rowChunk <- 100
  } else {
    rowChunk <- tmax
  }

  simDat <- nodestartDef # initiating data.frame
  simDat[2:(rowChunk + delay - 1), ] <- NA
  simDat[1:delay, ] <- nodestartDef

  t <- 2
  while (t <= nrow(simDat)) {
    row = t + delay - 1
    simDat[row, ] <- nextStep(dat = simDat[c((row-delay), (row-1)), ],
                              gen = genotypeDef[1,], delay = delay)

    # If any node has an exogenous supply
    if (!is.null(exogenousSupply)) {
      # add the exogenous amount to the value calculated by nextStep
      simDat[row, names(exogenousSupply)] <- simDat[row, names(exogenousSupply)] + unname(exogenousSupply)
    }

    # If reached steady state, return simDat
    if(all(round(simDat[row,], steadyThreshold) == round(simDat[row - 1,], steadyThreshold))) {
      simDat = simDat[delay:row, ]
      return(list(simulation = simDat, stable = T))
    }

    # If tmax has been reached (if there even is one), return simDat
    if (!is.na(tmax) & t == tmax) {
      warning("The maximum timestep has been reached without achieving stability.")
      simDat = simDat[delay:row, ]
      return(list(simulation = simDat, stable = F))
    }

    # If any node has reached infinity
    if (any(is.infinite(unlist(simDat[row, ])))) {
      warning(paste0("The simulation was terminated at time ", t, " as the following node/s reached infinity: ",
                    paste(names(simDat)[is.infinite(unlist(simDat[row, ]))], collapse = ", "), "."))
      simDat = simDat[delay:row, ]
      return(list(simulation = simDat, stable = F))
    }

    # If simDat has been filled without reaching steady state or tmax, add more rows
    if (row == nrow(simDat)) {
      simDat[(row + 1):(row + rowChunk), ] <- NA
    }

    t <- t + 1
  }
}

#' A wrapper function that allows you to run simulations of a network under
#' many different conditions.
#'
#' This function allows you to set up a variety of genotype and starting node
#' conditions to be simulated. It also allows you to test the outcome of
#' simulations under randomly assigned starting values. The function will make
#' sure to include one wild type condition (all genotypes set to 1) regardless
#' of if specified by the user.
#' @param folder the model folder generated by the buildModel function.
#' @param delay the amount of delay for any delayed transport. Default set to 2.
#' @param tmax the maximum number of timesteps for which to simulate.
#' @param steadyThreshold the number of decimal places to which node values must
#'             be equivalent to be considered a steady state. This threshold must
#'             be passed for all nodes.
#' @param exogenousSupply specifies if the value of a node (or nodes) is
#'               determined by an outside supply. In this case, the value of the
#'               node is supplied by the user and remains consistent throughout
#'               the course of the simulation. The default value for this
#'               argument is NULL. To specify nodes with an exogenous supply,
#'               provide a data frame with column names corresponding to the
#'               values of the nodes, with each vector member named after their
#'               respective node.
#' @param priorScreen logical. Specifies if the function should collect
#'               modifier values generated from generated prior distributions.
#' @param saveOutput logical. Default set to FALSE. Indicates if the output of
#'               simulation screen should be automatically saved in the
#'               provided folder location upon completion.
#' @param robustnessTest logical. Defaults to FALSE. Specifies if the nextStep
#'               function being used is part of a network robustness check.
#' @param altTopologyName default to NULL. If robustnessTest = T, this argument
#'               allows the user to keep the generated alternate nextStep function
#'               with a specific name. If no name is provided, the alternate
#'               nextStep functions will be names nextStepAlt.R.
#' @param report Logical, defaults to FALSE. Indicates if the index of the
#'               completed simulations is returned.
#' @importFrom stats runif
#' @export

setupSims <- function(folder,
                      delay = 2,
                      tmax = NA,
                      steadyThreshold = 4,
                      exogenousSupply = NULL,
                      priorScreen = T,
                      saveOutput = F,
                      robustnessTest = F,
                      altTopologyName = NULL,
                      report = F) {
  # loading parameter values
  if (priorScreen == T) {
    if (!file.exists(paste0(folder, "/priorDef.RData"))) {
      stop("You have requested to use modifer values generated from a prior distribution, but there is no priorDef.RData file in the folder indicated.")
    }
    load(paste0(folder, "/priorDef.RData"))
    genotypeDef <- priorDef
  } else {
    load(paste0(folder, "/genotypeDef.RData"))
  }

  load(paste0(folder, "/nodestartDef.RData"))

  # Ensuring that the first row of any screening dataframes contain a wildtype condition in the first row
  nodestartDef    <- tidyScreen(nodestartDef, "nodestartDef")
  genotypeDef     <- tidyScreen(genotypeDef, "genotypeDef")
  exogenousSupply <- tidyScreen(exogenousSupply, "exogenousSupply", exogenous = T)

  # Run simulations
  sims <- list()
  i = 1
  for (d in 1:nrow(nodestartDef)) {
    for (g in 1:nrow(genotypeDef)) {
      # creating a placeholder value sup so that can still use for loop when
      # exogenousSupply == NULL
      if (is.null(exogenousSupply)) {sup <- 1
      } else {sup <- nrow(exogenousSupply)}

      for (ex in 1:sup) {
        simulation = simulateNetwork(folder = folder,
                                     delay = delay,
                                     tmax = tmax,
                                     genotype = genotypeDef[g, ],
                                     startingValues = nodestartDef[d, ],
                                     exogenousSupply = if (is.null(exogenousSupply)) {NULL} else {exogenousSupply[ex, ]},
                                     robustnessTest = robustnessTest,
                                     altTopologyName = altTopologyName)

        sims[[i]] <- list(scenario = list(genotype = genotypeDef[g, ],
                                          startingValues = nodestartDef[d, ],
                                          exogenousSupply = if (is.null(exogenousSupply)) {NULL} else {exogenousSupply[ex, ]}),
                          simulation = simulation$simulation,
                          stable = simulation$stable)
        if (report == T) {
          print(paste("Simulation", i, "out of",
                      nrow(nodestartDef) * nrow(genotypeDef) * sup,
                      "completed..."))
        }

        i = i + 1
      }
    }
  }

  output <- list("modelFolder" = folder,
                 "parameters" = c("tmax" = tmax, "delay" = delay),
                 "screen" = sims)

  if (saveOutput == T) {
    if (!is.null(altTopologyName)) altTopologyName <- paste0(altTopologyName, "_")
    save(output,
         file = paste0(folder, "/", altTopologyName, "allSims.RData"))
  }

  return(output)
}

#' A function to generate genotype screens.
#'
#' Will generate genotype screens which considers compartmental information,
#' and allows for the possibility of multiple types of mutation.
#' @param folder the model folder generated by the buildModel function.
#' @param numMutations how many concurrent mutations do you want to test.
#' @param mutationVal for each combination of mutated genes, what value should
#'        the genes take on? Default is set to 0 (knockout).
#' @param returnExcel default set to FALSE. If TRUE, will create an excel file
#'        and save it in the model folder. This file will contain a matrix
#'        showing all of the genotype combinations that have been screened. This
#'        can be used to record any existing experimental outcomes, to be
#'        compared against simulated outcomes later on.
#' @param graft default set to FALSE. Indicates if the user wants to
#'        consider differential expression between compartments.
#' @importFrom utils combn
#' @importFrom utils write.table
#' @export

genotypeScreen <- function(folder,
                           numMutations = 1,
                           mutationVal = 0,
                           returnExcel = FALSE,
                           graft = FALSE) {
  if (file.exists(paste0(folder, "/genotypeDef.RData"))) {
    load(paste0(folder, "/genotypeDef.RData"))
  } else {
    source(paste0(folder, "/genotypeDef.R"))
  }

  if (nrow(genotypeDef) > 1) {
    warning("Overwrote existing extended genotype screen.")
    genotypeDef <- genotypeDef[1, ]
  }

  # collect the compartment extention of nodes
  comp = unlist(strsplit(colnames(genotypeDef), "_"))[c(F, T)]

  compartments <- vector("list", length = length(unique(comp)))
  names(compartments) <- unique(comp)

  for (i in 1:length(compartments)) {
    compartments[[i]] <- colnames(genotypeDef)[which(comp == unique(comp)[i])]
  }

  if (graft == F) {
    noComp <- unlist(strsplit(colnames(genotypeDef), "_"))[c(T, F)]
    genotypeDef[2:((numCombn(length(unique(noComp)), numMutations)*length(mutationVal)) + 1), ] <- 1
  } else {
    genotypeDef[2:(numCombn(ncol(genotypeDef), numMutations)*length(mutationVal) + 1), ] <- 1
  }

  if (graft == F){
    combGen <- combn(unique(noComp), numMutations)
    for (i in 2:nrow(genotypeDef)) {
      genotypeDef[i, which(noComp %in% combGen[, i - 1])] <- mutationVal
    }
  } else {
    combCol <- combn(ncol(genotypeDef), numMutations)
    for (i in 2:nrow(genotypeDef)) {
      genotypeDef[i, combCol[, i - 1]] <- mutationVal
    }
  }

  save(genotypeDef, file = paste0(folder, "/genotypeDef.Rdata"))
  return("File overwritten.")

  if (returnExcel == T) {
    sheets = vector("list", length = length(mutationVal))
    names(sheets) <- paste0("MutationVal=", mutationVal)

    spreadSheet <- matrix(NA, ncol = ncol(nodestartDef), nrow = nrow(genotypeDef))

    colnames(spreadSheet) <- colnames(nodestartDef)
    mutated <- genotypeDef != 1
    rows <- apply(mutated, 1, which)
    rowNames <- lapply(rows, names)
    rownames(spreadSheet) <- c("WT", sapply(rowNames, paste, collapse = ", ")[-1])

    write.table(spreadSheet,
                file = paste0(folder, "/experimentalData_mutationVal=",mutationVal,".csv"),
                sep = ",", row.names = T, col.names = NA)
  }
}


#' A function to generate a number of random starting point reassignments.
#'
#' Starting points will be generated for each node, pulled from a uniform
#' distribution. The existing starting values in the model folder will not
#' be overwritten.
#' @param folder the model folder generated by the buildModel function.
#' @param restarts the number of randomly assigned starting points that you
#'        want to test.
#' @param minVal default set to 0. The minimum value for a node to be.
#' @param maxVal default set to 2. The maximum value for a node to be.
#' @export

randomStartScreen <- function(folder,
                              restarts,
                              minVal = 0,
                              maxVal = 2) {
  if (minVal < 0) {
    minVal = 0
    warning("Expression levels cannot be below 0. Have reassigned the minimum
            value to 0.")
  }

  if (file.exists(paste0(folder, "/nodestartDef.RData"))) {
    load(paste0(folder, "/nodestartDef.RData"))
  } else {
    source(paste0(folder, "/nodestartDef.R"))
  }

  nodestartDef[(nrow(nodestartDef) + 1):(nrow(nodestartDef) + restarts), ] <- round(runif(restarts*ncol(nodestartDef),
                                                            minVal, maxVal), 4)

  save(nodestartDef, file = paste0(folder, "/nodestartDef.Rdata"))
}

#' A function to generate all combinations of two vectors containing the values
#' to be screened for two nodes. This function will also include the possibility
#' of no exogenous values being provided in the form of NA.
#'
#' @param nodes a vector containing the names of two nodes of interest
#' @param screen1 a vector containing all the values to be tested for the
#'                first listed node.
#' @param screen2 a vector containing all the values to be tested for the
#'                second listed node.
#' @export
exogenousScreen <- function(nodes, screen1, screen2) {
  # making sure that there is a condition where no exogenous hormone is provided
  if (!0 %in% screen1) {screen1 <- c(0, screen1)}
  if (!0 %in% screen1) {screen1 <- c(0, screen1)}

  combo <- expand.grid(screen1, screen2)
  colnames(combo) <- nodes
  combo
}

#' A function to calculate the number of unique combinations of a vector
#' of length n of sample size r.
#'
#' @param n number of items in the vector.
#' @param r the size of the sample.

numCombn <- function(n, r) {
  if (r > n) {
    stop("Your sample size is greater than the length of the vector.")
  }

  factorial(n)/(factorial(r)*factorial(n-r))
}

#' A function to make sure that data.frames containing conditions to screen
#' are organised correctly. The wild-type condition is made to come first,
#' and any duplicate rows are removed.
#'
#' @param frame a data.frame
#' @param name a string giving the name of the data frame in case a warning is generated.
#' @param exogenous logical. Indicates if the wild type row should be 1s or 0s.
#'                  if checking modifier or node screens, should be set to F.
#'                  If checking exogenous screens, should be T.
#' @importFrom prodlim row.match
tidyScreen <- function(frame, name, exogenous = F) {
  WT <- as.numeric(!exogenous)

  warn <- NULL # initiate vector to store warning messages.

  # remove any row duplication
  if (any(duplicated(frame))) {
    frame <- frame[!duplicated(frame), ]
    warn <- c(warn, "Have removed duplicate rows from the %s object.")
  }

  if (!all(frame[1, ] == WT)) { # if the first row is not WT, search for WT rows
    WTrow <- row.match(rep(WT, ncol(frame)), frame)

    if (is.na(WTrow)) { # if there is no WT row, add an initial WT row
      frame <- rbind(rep(WT, ncol(frame)), frame)
      warn <- c(warn, "Have added a row containing the baseline condition to the %s object.")
    } else { # if there is a WT row, move it to the first row
      OTHERrow <- (1:nrow(frame))[-WTrow]
      frame[1:nrow(frame), ] <- frame[c(WTrow, OTHERrow), ]
      warn <- c(warn, "Have moved the row containing the baseline condition to the first row in the %s object.")
    }
  }

  if (!is.null(warn)) { # provide warning messages in case any changes were made
    sapply(sprintf(warn, name), warning, call. = F)
  }

  frame
}

#' A function to generate a screen of modifier conditions based on a set of
#' prior distributions.
#'
#' @param folder a string stating the directory of the folder containing
#'        your generated model.
#' @param priorDistribution states the prior distribution to be used to generate
#'        modifier values. If of length 1, the prior will be applied to all
#'        modifier values. If length is greater than 1, the vector must be
#'        named with the corresponding modifier name. To specify a value
#'        for particular modifiers, provide the value of that modifier
#'        instead of the distribution to be used.
#' @param n the number of simulations for which a set of priors will be generated.
#' @param savePriors logical. If the prior screen should be saved in the provided
#'        folder.
#' @param returnVals logical. If the output should be returned to the user.
#' @importFrom stats rlnorm
#' @export

modifierPriorScreen <- function(folder, priorDistribution = "rlnorm", n,
                                savePriors = T, returnVals = F) {
  load(paste0(folder, "/genotypeDef.RData"))

  # make sure that the priorDistribution has the correct naming convention
  if (length(priorDistribution) == 1) {
    priorDistribution <- rep(priorDistribution, ncol(genotypeDef))
    names(priorDistribution) <- colnames(genotypeDef)
  } else {
    # check if anything has been missnamed
    if (length(setdiff(names(priorDistribution), colnames(genotypeDef))) > 1 |
        length(setdiff(colnames(genotypeDef), names(priorDistribution))) > 1) {
      stop("priorDistribution vector must have the same names as the network nodes.")
    }
  }

  # giving object a different name to distinguish from defined set of
  # experimental conditions
  priorDef <- genotypeDef[1, ]

  # will want to allow for different distributions in the future!!! Maybe even
  # user specified distributions?
  priorDef[2:(n + 1), names(priorDistribution)[priorDistribution == "rlnorm"]] <- rlnorm(n * sum(priorDistribution == "rlnorm"))

  # replace vals with specific numbers if provided by user
  givenVals <- sapply(priorDistribution, function(x) suppressWarnings(as.numeric(x)))

  if (any(!is.na(givenVals))) {
    for (mod in names(givenVals[!is.na(givenVals)])) {
      priorDef[2:(n + 1), mod] <- givenVals[[mod]]
    }
  }

  if (savePriors == T) save(priorDef, file = paste0(folder, "/priorDef.RData"))

  if (returnVals == T) return(priorDef)
}



