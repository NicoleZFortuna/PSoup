---
title: "Get started using peaSoup"
author: "Nicole Fortuna"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started using peaSoup}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### Purpose and design philosophy for peaSoup

#### Commentary on the collection of prior knowledge

### Walkthrough of how to use peaSoup

This is a short tutorial to demonstrate how you can use peaSoup to simulate network outcomes. Examples will use data that is included in this package.

First start by building a diagram of your network using some editor that can support SBGN diagrams of the Activity Flow language (I recommend [Newt Pathway Viewer & Editor](https://web.newteditor.org/)). 

```{r, echo=FALSE, out.width="50%", fig.cap="Figure 1. An example of a network diagram that can be produced using Newt."}
knitr::include_graphics("DunAFgenotype.jpg")
```

Once you are happy with your diagram, click `File` -> `Export` -> `SBGN-ML Plain`. This will generate a text file representation of your diagram using SBGN markdown language. You will need to use the `convertSBGNdiagram` function to translate this text file into Network object that is easy to use.

```{r}
library(peaSoup)
PeaNetwork = convertSBGNdiagram("../data-raw/DunAFgenotype.sbgn", "PeaNetwork")
PeaNetwork
```

This Network object can then be passed to a function called 'buildModel' which will generate all
the information that is required to run a simulation of your network. You will need to provide a directory pathway for your model information to be stored in. If there already exists a folder of the specified name, this function will not overwrite the folder unless requested to do so (you would need to pass an additional argument `forceOverwrite = TRUE` to the buildModel function.)

```{r, eval=FALSE}
folder = "~/Desktop/Model"
buildModel(PeaNetwork, folder, dataFrame = TRUE)
```

To access the information, all you need to do is source the folder into the local environment:
```{r, echo=FALSE}
folder = "~/Desktop/Model"
```


```{r}
load(paste0(folder, "/genotypeDef.RData"))
load(paste0(folder, "/nodestartDef.RData"))
```

Within the folder that you have built, there will be three objects. Two of these objects will be data.frames specifying values to be fed to the model: one will give the genotypes and their wild type values, the second will give the starting node values for the simulation.

```{r}
genotypeDef

nodestartDef
```

For these data.frames, each row can be considered as experimental condition that will need to be simulated. The data.frames are initially only a single row long, but the user can add any number of rows containing conditions that they wish to test (more on this later). These rows can be added manually, or they can be automatically generated using the purpose built functions: `genotypeScreen` and `randomStartScreen`.

In addition to these two data.frames, there will also be a script defining a function that is called `nextStep`. This function has been automatically generated from the PeaNetwork object based on the original diagram. 

```{r, echo=FALSE, out.width="80%", fig.cap="Figure 1. The nextStep function, which is automatically generated by the buildModel function."}
knitr::include_graphics("buildModelOutput.png")
```

This function is what will be doing most of the work when running simulations of the network. This function is what calculates the node values at each step in time. It contains a series of difference equations which are the mathematical description of the information contained in the diagram.

This function has been provided as script viewable to the user in order to make sure that the automatic translation that has been done by the package is 100% transparent. In addition, it provides an opportunity for the user to modify the equations if they wish to do so. This is a potentially a dangerous thing to attempt as it is possible to introduce errors or bugs into the simulations. If so, the user will be responsible to create usable functions.

Once these three data objects have been created in our Model folder, the path directory of this folder can be provided as input to run our simulation. If we want to run a single simulation, we can call the `simulateNetwork` function.

```{r}
simulation <- simulateNetwork(folder, tmax = 100) 
head(simulation)
```

As the folder contains all of our genotype information, node starting values, as well as the script for the `nextStep` function, all the information to run the simulation is already there. The only thing left to specify is the length that we wish to simulate the network. Functionality will be provided so that the user can simulate until the system finds a stable state.

#### How to set up a simulation screen
It will often be the case that you do not wish to test a network only under a single condition. Sometimes there are a few specific conditions that you want to test, other times you want to conduct as exhaustive search. In either case, you will need to use the `setupSims` function, rather than the `simulateNetwork` function.

If there are a few specific conditions that you want to test, you can simply add rows to the respective data.frames. These rows will each be considered a unique starting condition for a simulation.

In the case that you want to do an exhaustive search, the `genotypeScreen` and `randomStartScreen` are useful for automating the construction of the appropriate data.frames.

The `genotypeScreen` function will generate a data.frame with up combinations of up to however  many mutations that you would like to explore. You can also specify the genotype values that you would like to be used for your mutations. You can specify if you would like for the function to output an excel file in addition to the data. The excel file will be empty, but will have row and column names that correspond to the generated data.frame. This file can be filed with values that have been derived from the literature for the purpose of validating your model. You do not need to fill every value, as only the provided info will be used to validate.


### Algebraic Rules 

### Organising experimental outputs into bins

### Comparing experimental outputs to simulated outputs

### Recommended readings
