---
title: "PSoup Walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(PSoup)
```

```{r echo = FALSE}
# run  buildDependentFiles.R to generate the files that will be used to produce
# this article. Below are the directories to the generated files.

folder1 = "Model1"
folder2 = "Model2"
```

This is a short tutorial to demonstrate how you can use PSoup to simulate network outcomes. Examples will use data that is included in this package so that you can follow along even without your own network.

## Importing a diagram

First start by building a diagram of your network using an editor that can support SBGN diagrams of the Activity Flow language (I recommend [Newt Pathway Viewer & Editor](https://web.newteditor.org/)). When building your diagram, make sure that you specify that map is of type AF, and that you only use symbols from the Activity Flow Palette. This diagram will be based on the series of statements that you have constructed describing your system. For advice on how to construct your statements, view the 'Organising Prior Knowledge' article. For a detailed description of how to use the Newt editor, view the 'Newt Editor Instructions' article. To see the algebraic rules that PSoup uses to convert a diagram to a mathematical model view the 'Algebraic Rules' article.

<center>
```{r, echo=FALSE, out.width="50%", fig.cap="Figure 1. An example of a network diagram that can be produced using the Newt online editor."}
knitr::include_graphics("DunAFgenotype.jpg")
```
</center>

Once you are happy with your diagram, click `File` -> `Export` -> `SBGN-ML Plain`. This will generate a text file representation of your diagram using SBGN markdown language. You will then need to use the `convertSBGNdiagram` function to translate this text file into a Network object that is easy to use. In the below example, the `getExampleDiagram` function has been created to give the user access to the .sbgn file contained in the PSoup package. It should only be used if the user wants to use the network displayed above. If you have your own diagram, ignore this function.

```{r, eval=FALSE}
# provide the directory for where the sbgn file will be saved as an argument
getExampleDiagram("~/Desktop/Diagram")

PeaNetwork <- convertSBGNdiagram(file = "~/Desktop/Diagram/DunAFgenotype.sbgn", 
                                 networkName = "PeaNetwork")
PeaNetwork
```

```{r, echo=FALSE}
PeaNetwork <- convertSBGNdiagram(file = "../inst/DunAFgenotype.sbgn", 
                                 networkName = "PeaNetwork")
PeaNetwork
```

The above network object is natively available in the PSoup package, and can therefore be called directly:

```{r}
peaNetwork
```

## Generating a model from a diagram

Network objects can then be passed to a function called `buildModel` which will generate all the information that is required to create a mathematical description of your network. You will need to provide a directory pathway for your model information to be stored in. If there already exists a folder of the specified name, this function will not overwrite the folder unless requested to do so (you would need to pass an additional argument `forceOverwrite = TRUE` to the buildModel function.)

```{r, eval=FALSE}
folder = "~/Desktop/Model"
buildModel(PeaNetwork, folder1, forceOverwrite = TRUE)
```

Within the folder that you have built, there will be three objects. Two of these objects will be data frames specifying values to be fed to the model: one will give the genotypes and their baseline values, the second will give the starting node values for the simulation.

To access the information, all you need to do is load the files into the local environment:

```{r eval = FALSE}
load(paste0(folder, "/genotypeDef.RData"))
load(paste0(folder, "/nodestartDef.RData"))
```

```{r echo = FALSE}
getwd()
load(paste0(folder1, "/genotypeDef.RData"))
load(paste0(folder1, "/nodestartDef.RData"))
load(paste0(folder1, "/simulation.RData"))
```

```{r}
genotypeDef

nodestartDef
```

For these data frames, each row can be considered as an experimental condition to be simulated. Data frames are initially only a single row long, but the user can add any number of rows containing conditions that they wish to test (more on this later). These rows can be added manually, or they can be automatically generated using the purpose built functions: `genotypeScreen` and `randomStartScreen`.

In addition to these two data frames, the folder you generate will also contain a script defining a function that is called `nextStep`. This function has been automatically generated from the PeaNetwork object based on the original diagram. 

<center>
```{r, echo=FALSE, out.width="80%", fig.cap="Figure 1. The nextStep function, which is automatically generated by the buildModel function."}
knitr::include_graphics("buildModelOutput.png")
```
</center>

This function is what will be doing most of the work when running simulations of the network. This function is what calculates the node values at each step. It contains a series of difference equations which are the mathematical description of the information contained in the diagram.

This function has been provided as a script accessible to the user in order to make the translation of the provided diagram transparent to the user. In addition, it provides an opportunity for the user to modify the equations if they wish to do so. This is a potentially a dangerous thing to attempt as it is possible to introduce errors or bugs into the simulations. If the user decides to modify the code, they will be responsible for creating usable functions. In addition, the user should be wary that by modifying the code, that they may be creating runaway dynamics that cause simulations to never reach stability. Even if this is the case, the `maxStep` argument will prevent the simulation from running for eternity. An additional fail safe, is that if any of the nodes reaches infinity (`Inf`), the simulation will be terminated and an error generated to inform the user.

Once these three data objects have been created in your specified folder, the path directory of this folder can be provided as input to run simulations. If we want to run a single simulation, we can call the `simulateNetwork` function.

```{r eval=FALSE}
simulation <- simulateNetwork(folder, maxStep = 100) 
head(simulation)
```

```{r echo=FALSE}
head(simulation)
```


As the folder contains all of our genotype information, node starting values, as well as the script for the `nextStep` function, all the information to run the simulation is available. The simulation will run until the system reaches stability, unless one of the exceptions listed above occurs.

To quickly inspect the outcome of a simulation, the `fastPlot` function can be called as below. As the genotypeDef and nodestartDef data frames in our model folder only contain the baseline condition, the system is already at stability, and therefore the plot shows no change. Note that in the plot below that the node values have been log transformed. The `fastPlot` function has an argument `logTransform` which by default is set to     `TRUE`. This transformation makes it easier to discern the releative differences for positive and negative changes in the system. If you would like to see the true node values, set this argument to `FALSE`. This function is useful to make a quick diagnosis of the system. To make high quality plots, use existing R plotting tools.

```{r, out.width="80%", dpi=300, fig.align = 'center'}
fastPlot(simulation)
```

## Setting up a set of simulation conditions
It will usually be the case that you want to test a network under multiple conditions. Sometimes there are a few specific conditions that you want to test, other times you want to conduct an exhaustive search. In either case, you will need to use the `setupSims` function, rather than the `simulateNetwork` function.

If there are a few specific conditions that you want to test, you can simply add rows to the respective data frames. These rows will each be considered a unique condition for a simulation.

```{r}
# add additional rows filled with baseline values
genotypeDef[2:3, ] <- 1

# specify mutant conditions in the additional rows
genotypeDef[2, 3] <- 0
genotypeDef[3, 1:2] <- 0.5

genotypeDef
```

In the example above, the second row represents an 'experimental' condition where the function of RMS2 in the scion (shoot) has been knocked out. The third row represents a condition where the function of RMS1 has been reduced to half of its capacity in both the root, and the scion. Once you have generated the specific experimental conditions that you want to test, you must save the `genotypeDef` object back into your model folder (for example with a line of code like `save(genotypeDef, file = paste0(folder, "/genotypeDef.RData"))`).

In the case that you want to do an exhaustive search, the `genotypeScreen` is useful for automating the construction of the appropriate data frames. The output of this function will automatically overwrite the genotypeDef object in your folder, so you will not need to explicitly save your genotypeDef object if you use this function.

```{r eval=FALSE}
genotypeScreen(folder)

load(paste0(folder, "/genotypeDef.RData"))
genotypeDef 
```
```{r echo=FALSE}
load(paste0(folder2, "/genotypeDef.RData"))
genotypeDef 
```

The `genotypeScreen` function will generate a data frame with combinations of up to however many mutations that you would like to explore, including the genotype expression values that you would like to use for your mutations. In the case that a gene is attached to multiple nodes in different compartments, you can choose whether to have differential expression in the different compartments. The default condition `graft = FALSE` indicates that all nodes modified by the same gene should be modified identically. To allow for differential expression in different compartments of the system, specify `graft = TRUE`. <span style="color:blue;">You can also specify if you would like for the function to output an excel file in addition to the data. The excel file will be empty, but will have row and column names that correspond to the generated data frame. This file can be filed with values that have been derived from the literature for the purpose of validating your model. You do not need to fill every value, as only the provided information will be used to validate the simulated data.</span>

```{r, out.width="80%", dpi=300, fig.align = 'center'}
fastPlot(simulation)
```

The sister function to `genotypeScreen` is `randomStartScreen`. This function will generate a data frame corresponding to the nodes of the network, with values indicating the value of the node at the start of the simulation. To use this function, you must provide the model folder path, as well as the number of restart values that you want to generate. In addition you can also indicate what the maximum and minimum values that you want for nodes. The default minimum is set to 0, while the default maximum value is 2. This function will pull values from a uniform distribution bound by these values.

```{r eval=FALSE}
randomStartScreen(folder, restarts = 5)

load(paste0(folder, "/nodestartDef.RData"))
nodestartDef 
```

```{r echo=FALSE}
load(paste0(folder2, "/nodestartDef.RData"))
nodestartDef 
```

### Adding an exogenous supply to a system

In addition to being able to modify the genes and node values of the system, it is also possible to supply an external source to a node. This external supply is constantly given throughout the course of the simulation, with the amount added at each timepoint to the native value in the simulation. An exogenous supply for a node can be specified by providing a named vector, or data frame to the `exogenousSupply` argument in either the `simulateNetwork` or `setupSims` functions. Where the name of the vector or columns correspond to a node in the network (only nodes for which an exogenous supply will be provided should be included).

It is possible to quickly set up a two dimensional screen of exogenous treatments to the system by using the `exogenousScreen` function.

```{r eval=FALSE}
exogenousScreen(c("Strigolactone_S", "Cytokinin_R"), 
                screen1 = 1:3, 
                screen2 = 1:3, 
                folder)

load(paste0(folder, "/exogenousDef.RData"))
exogenousDef
```

```{r echo=FALSE}
load(paste0(folder2, "/exogenousDef.RData"))
exogenousDef
```

### Set up a screen of priors from a distribution

There is one more useful function when it comes to setting up a set of conditions to be simulated. The function `modifierPriorScreen` is designed to generate a data frame containing modifier values that have been pulled from a prior distribution of values. As of now, only a log normal distribution can be used, but more distributions may be added in the future. The argument `priorDistribution` is automatically set to `"rlnorm"` which indicates that all modifier values should be pulled from a log normal distribution. It is possible to instead provide a vector named after the modifiers. In this case you can indicate if certain nodes should maintain a particular value, while others have values pulled from a distribution. You can choose the number of experimental conditions with generated modifier values with the argument `n`. Note that the data frame produced from this function is called `priorDef` rather than `genotypeDef`. This is to recognise that use of the `modifierPriorScreen` function is associated with running a robustness check on the topology of the network.

```{r eval=FALSE}
modifierPriorScreen(folder, n = 5)

load(paste0(folder, "/priorDef.RData"))
priorDef
```

```{r echo=FALSE}
load(paste0(folder2, "/priorDef.RData"))
priorDef
```

You should view the model folder that you generate to run simulations as a record. You can generate a variety of different screens, not all of which you need to explore at the same time. When generating screens of parameter values, those screens can be saved in the folder for record keeping. They can also be accessed by simulation functions so that they do not need to be passed to the function manually.

## Executing a simulation screen

Running a simulation screen can be done easily by using the `setupSims` function. This function will pull data objects from the model folder that you generated, and will simulate every row combination from each data object. Usually the user will not need to indicate which data objects to pull from, the only exception is if the user wants to perform a robustness check on the topology of the network. In which case, the user will need to have generated an `priorDef.RData` object in their model folder, and supply the argument `robustnessTest = FALSE` when using the `setupSims` function.

In the above examples we have generated a series of objects that can be used to run simulations. A `genotypeDef` object representing a knockout screen for each of the genotypes represented in our originating diagram. A `nodestartDef` object representing random start values for nodes. A `priorDef` object which randomly assigns modifier values (genotype values) for the purpose of exploring how topology restricts the behaviour of the system. And finally an `exogenousDef` object that can be used to represent the addition of some substance to the system. Once you have generated all the object to run explorations, you can choose to explore either multiple of these objects at one time, or explore them independently. The only restriction is that you cannot explore both the `genotypeDef` and `priorDef` objects at the same time as they have different purposes. Given the selections that you make, the output simulations will be named to reflect those selections.

We can start by exploring the behaviour of the modifying genotype (modifier) values according to the screen that we automatically generated above.

```{r eval = FALSE}
setupSims(folder, nodestartBaseline = T)
load(paste0(folder, "/genotypeDef_Sims.RData"))
```

```{r echo = FALSE}
load(paste0(folder2, "/genotypeDef_Sims.RData"))
```

Lets quickly inspect the outcome of one of these simulations:

```{r}
fastPlot(output$screen[[6]])
```






<!-- modifierPriorScreen(folder, n = 1000) -->
<!-- load(paste0(folder, "/priorDef.RData")) -->
<!-- priorDef -->

<!-- boxplot(log(priorDef)) -->


<!-- priorSims <- setupSims(folder, report = T, priorScreen = T, tmax = 100) -->
<!-- save(priorSims, file = paste0(folder, "/priorSims.RData")) -->
<!-- load(paste0(folder, "/priorSims.RData")) -->

<!-- fastPlot(priorSims$screen[[7]]) -->
<!-- unique(stabilityVector(priorSims)) -->

<!-- stableNodes <- finalStates(priorSims$screen) -->

<!-- boxplot(log(stableNodes), cex = 0.5, cex.axis = 0.5) -->
<!-- abline(0,0, col = "red") -->

<!-- plot(stableNodes$FB_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$FB_R, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$SL_R, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$SL_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$Perception_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->

<!-- priorDef[which(stableNodes$SL_P == max(stableNodes$SL_P)), ] -->

<!-- plot(stableNodes$SL_R, stableNodes$SL_S, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->

<!-- decreasingBO <- stableNodes[order(stableNodes$InhibitGrowth_B), ] -->

<!-- plot.ts(decreasingBO[, c("InhibitGrowth_B", "FB_P", "FB_R", "SL_P", "SL_R", "Perception_P")]) -->



