---
title: "PSoup Walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PSoup Walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(PSoup)
```

```{r echo = FALSE}
# run  buildDependentFiles.R to generate the files that will be used to produce
# this article. Below are the directories to the generated files.

folder1 = "Model1"
folder2 = "Model2"
```

This is a short tutorial to demonstrate how you can use PSoup to simulate network outcomes. Examples will use data that is included in this package so that you can follow along even without your own network.

## Importing a diagram

First start by building a diagram of your network using an editor that can support SBGN diagrams of the Activity Flow language (I recommend [Newt Pathway Viewer & Editor](https://web.newteditor.org/)). When building your diagram, make sure that you specify that map is of type AF, and that you only use symbols from the Activity Flow Palette. This diagram will be based on the series of statements that you have constructed describing your system. For advice on how to construct your statements, view the 'Organising Prior Knowledge' article. For a detailed description of how to use the Newt editor, view the 'Newt Editor Instructions' article. To see the algebraic rules that PSoup uses to convert a diagram to a mathematical model view the 'Algebraic Rules' article.

<center>
```{r, echo=FALSE, out.width="50%", fig.cap="Figure 1. An example of a network diagram that can be produced using the Newt online editor."}
knitr::include_graphics("DunAFgenotype.jpg")
```
</center>

Once you are happy with your diagram, click `File` -> `Export` -> `SBGN-ML Plain`. This will generate a text file representation of your diagram using SBGN markdown language. You will then need to use the `convertSBGNdiagram` function to translate this text file into a Network object that is easy to use. To use the `convertSBGNdiagram` function, you will need to provide two arguments. The first is the file path for the .sbgn file that describes your diagram, the second argument asks you to provide a name for your network.

To trial using this function, first use the below code to import the native PSoup network. This function will save the DunAFgenotype.sbgn file in a location of your choosing. This function only exists to allow the user to interact with the sbgn file for the network displayed above. You will not need to use this function if you have your own diagram.

Using the provided sbgn file, we can generate a network object as demonstrated below.

```{r, eval=FALSE}
PeaNetwork <- convertSBGNdiagram(file = "~/Desktop/Diagram/DunAFgenotype.sbgn", 
                                 networkName = "PeaNetwork")
PeaNetwork
```

```{r, echo=FALSE}
PeaNetwork <- convertSBGNdiagram(file = "../inst/DunAFgenotype.sbgn", 
                                 networkName = "PeaNetwork")
PeaNetwork
```

The above network object is natively available in the PSoup package, and can therefore be called directly:

```{r}
peaNetwork
```

## Generating a model from a diagram

Network objects can then be passed to a function called `buildModel` which will generate all the information that is required to create a mathematical description of your network. You will need to provide a directory pathway for your model information to be stored in. If there already exists a folder of the specified name, this function will not overwrite the folder unless requested to do so (you would need to pass an additional argument `forceOverwrite = TRUE` to the buildModel function.)

```{r, eval=FALSE}
folder = "~/Desktop/Model"
buildModel(PeaNetwork, folder, forceOverwrite = TRUE)
```

Within the folder that you have built, there will be three objects. Two of these objects will be data frames specifying values to be fed to the model: one will give the genotypes and their baseline values, the second will give the starting node values for the simulation.

To access the information, all you need to do is load the files into the local environment:

```{r eval = FALSE}
# To access the genotype definition object
load(paste0(folder, "/genotypeDef.RData"))

# To access the starting node value definition object
load(paste0(folder, "/nodestartDef.RData"))
```

```{r echo = FALSE}
getwd()
load(paste0(folder1, "/genotypeDef.RData"))
load(paste0(folder1, "/nodestartDef.RData"))
load(paste0(folder1, "/simulation.RData"))
```

```{r}
genotypeDef

nodestartDef
```

For these data frames, each row can be considered as an experimental condition to be simulated. Data frames are initially only a single row long, but the user can add any number of rows containing conditions that they wish to test (more on this later). These rows can be added manually, or they can be automatically generated using the purpose built functions: `genotypeScreen` and `randomStartScreen`.

In addition to these two data frames, the folder you generate will also contain a script defining a function that is called `nextStep`. This function has been automatically generated from the PeaNetwork object based on the original diagram. 

<center>
```{r, echo=FALSE, out.width="80%", fig.cap="Figure 1. The nextStep function, which is automatically generated by the buildModel function."}
knitr::include_graphics("buildModelOutput.png")
```
</center>

This function is what will be doing most of the work when running simulations of the network. This function is what calculates the node values at each step. It contains a series of difference equations which are the mathematical description of the information contained in the diagram.

This function has been provided as a script accessible to the user in order to make the translation of the provided diagram transparent to the user. In addition, it provides an opportunity for the user to modify the equations if they wish to do so. This is a potentially a dangerous thing to attempt as it is possible to introduce errors or bugs into the simulations. If the user decides to modify the code, they will be responsible for creating usable functions. In addition, the user should be wary that by modifying the code, that they may be creating runaway dynamics that cause simulations to never reach stability. Even if this is the case, the `maxStep` argument will prevent the simulation from running for eternity. An additional fail safe, is that if any of the nodes reaches infinity (`Inf`), the simulation will be terminated and an error generated to inform the user.

Once these three data objects have been created in your specified folder, the path directory of this folder can be provided as input to run simulations. If we want to run a single simulation, we can call the `simulateNetwork` function.

```{r eval=FALSE}
simulation <- simulateNetwork(folder, maxStep = 100) 
head(simulation)
```

```{r echo=FALSE}
head(simulation)
```


As the folder contains all of our genotype information, node starting values, as well as the script for the `nextStep` function, all the information to run the simulation is available. The simulation will run until the system reaches stability, unless one of the exceptions listed above occurs.

To quickly inspect the outcome of a simulation, the `fastPlot` function can be called as below. As the genotypeDef and nodestartDef data frames in our model folder only contain the baseline condition, the system is already at stability, and therefore the plot shows no change. Note that in the plot below that the node values have been log transformed. The `fastPlot` function has an argument `logTransform` which by default is set to     `TRUE`. This transformation makes it easier to discern the releative differences for positive and negative changes in the system. If you would like to see the true node values, set this argument to `FALSE`. This function is useful to make a quick diagnosis of the system. To make high quality plots, use existing R plotting tools.

```{r, out.width="90%", dpi=300, fig.align = 'center'}
fastPlot(simulation)
```

## Setting up a set of simulation conditions
It will usually be the case that you want to test a network under multiple conditions. Sometimes there are a few specific conditions that you want to test, other times you want to conduct an exhaustive search. In either case, you will need to use the `setupSims` function, rather than the `simulateNetwork` function.

If there are a few specific conditions that you want to test, you can simply add rows to the respective data frames. These rows will each be considered a unique condition for a simulation.

```{r}
# add additional rows filled with baseline values
genotypeDef[2:3, ] <- 1

# specify mutant conditions in the additional rows
genotypeDef[2, 3] <- 0
genotypeDef[3, 1:2] <- 0.5

genotypeDef
```

In the example above, the second row represents an 'experimental' condition where the function of RMS2 in the scion (shoot) has been knocked out. The third row represents a condition where the function of RMS1 has been reduced to half of its capacity in both the root, and the scion. Once you have generated the specific experimental conditions that you want to test, you must save the `genotypeDef` object back into your model folder (for example with a line of code like `save(genotypeDef, file = paste0(folder, "/genotypeDef.RData"))`).

In the case that you want to do an exhaustive search, the `genotypeScreen` is useful for automating the construction of the appropriate data frames. The output of this function will automatically overwrite the genotypeDef object in your folder, so you will not need to explicitly save your genotypeDef object if you use this function.

```{r eval=FALSE}
genotypeScreen(folder)

load(paste0(folder, "/genotypeDef.RData"))
genotypeDef 
```

```{r echo=FALSE}
load(paste0(folder2, "/genotypeDef.RData"))
genotypeDef 
```

The `genotypeScreen` function will generate a data frame with combinations of up to however many mutations that you would like to explore, including the genotype expression values that you would like to use for your mutations. In the case that a gene is attached to multiple nodes in different compartments, you can choose whether to have differential expression in the different compartments. The default condition `graft = FALSE` indicates that all nodes modified by the same gene should be modified identically. To allow for differential expression in different compartments of the system, specify `graft = TRUE`. <span style="color:blue;">You can also specify if you would like for the function to output an excel file in addition to the data. The excel file will be empty, but will have row and column names that correspond to the generated data frame. This file can be filed with values that have been derived from the literature for the purpose of validating your model. You do not need to fill every value, as only the provided information will be used to validate the simulated data.</span>

The sister function to `genotypeScreen` is `randomStartScreen`. This function will generate a data frame corresponding to the nodes of the network, with values indicating the value of the node at the start of the simulation. To use this function, you must provide the model folder path, as well as the number of restart values that you want to generate. In addition you can also indicate what the maximum and minimum values that you want for nodes. The default minimum is set to 0, while the default maximum value is 2. This function will pull values from a uniform distribution bound by these values.

```{r eval=FALSE}
randomStartScreen(folder, restarts = 5)

load(paste0(folder, "/nodestartDef.RData"))
nodestartDef 
```

```{r echo=FALSE}
load(paste0(folder2, "/nodestartDef.RData"))
nodestartDef 
```

### Adding an exogenous supply to a system

In addition to being able to modify the genes and node values of the system, it is also possible to supply an external source to a node. This external supply is constantly given throughout the course of the simulation, with the amount added at each timepoint to the native value in the simulation. An exogenous supply for a node can be specified by providing a named vector, or data frame to the `exogenousSupply` argument in the `simulateNetwork` function. Where the name of the vector or columns correspond to a node in the network (only nodes for which an exogenous supply will be provided should be included). If giving an exogenous supply to a series of simulations, an exogenousDef object will need to be generated and saved in the Model folder. Once this has been done, when calling the `setupSims` function, the `exogenousSupply` argument must be set to TRUE.

It is possible to quickly set up a two dimensional screen of exogenous treatments to the system by using the `exogenousScreen` function.

```{r eval=FALSE}
exogenousScreen(c("Strigolactone_S", "Cytokinin_R"), 
                screen1 = 1:3, 
                screen2 = 1:3, 
                folder)

load(paste0(folder, "/exogenousDef.RData"))
exogenousDef
```

```{r echo=FALSE}
load(paste0(folder2, "/exogenousDef.RData"))
exogenousDef
```

### Set up a screen of priors from a distribution

There is one more useful function when it comes to setting up a set of conditions to be simulated. The function `modifierPriorScreen` is designed to generate a data frame containing modifier values that have been pulled from a prior distribution of values. As of now, only a log normal distribution can be used, but more distributions may be added in the future. The argument `priorDistribution` is automatically set to `"rlnorm"` which indicates that all modifier values should be pulled from a log normal distribution. It is possible to instead provide a vector named after the modifiers. In this case you can indicate if certain nodes should maintain a particular value, while others have values pulled from a distribution. You can choose the number of experimental conditions with generated modifier values with the argument `n`. Note that the data frame produced from this function is called `priorDef` rather than `genotypeDef`. This is to recognise that use of the `modifierPriorScreen` function is associated with running a robustness check on the topology of the network.

```{r eval=FALSE}
modifierPriorScreen(folder, n = 5)

load(paste0(folder, "/priorDef.RData"))
priorDef
```

```{r echo=FALSE}
load(paste0(folder2, "/priorDef.RData"))
priorDef
```

You should view the model folder that you generate to run simulations as a record. You can generate a variety of different screens, not all of which you need to explore at the same time. When generating screens of parameter values, those screens can be saved in the folder for record keeping. They can also be accessed by simulation functions so that they do not need to be passed to the function manually.

## Executing a simulation screen

Running a simulation screen can be done automatically by using the `setupSims` function. This function will pull data objects from the model folder generated by the user, and simulate every row combination from each data object. 

There are a number of arguments that can be used to specify the types of screens to be run. These arguments, which all take a logical value, are set to `FALSE` by default.

| setupSims argument | Purpose |
| - | ---- |
| exogenousSupply | Specifies if the `exogenousDef.RData` object should be imported in order to explore how the exogenous supply of resources affect the functioning of the network. |
| priorScreen | Specifies if the `priorDef.RData` should be imported in place of the `genotypeDef.RData` in order to explore how modifiers influence the functioning of the system when drawn from a prior distribution. |
| robustnessTest | Indicates if the simulation being conducted is exploring the behaviour of neighboring network configurations. |
| genotypeBaseline | Specifies if only the baseline condition for modifiers should be explored regardless of the number of rows contained in the `genotypeDef` object. |
| nodestartBaseline | Specifies if only the baseline condition for starting node values should be explored regardless of the number of rows contained in the `nodestartDef` object. |

As a consequence of the above argument defaults, the default simulation is to explore every combination or rows contained in the `genotypeDef` and `nodestartDef` objects. From there, the choice can be made to also explore every combination of exogenously supplied resource as well, or to replace the curated `genotypeDef` object with the randomly generated `priorDef` object. Given what the user wants to explore at the time the `genotypeDef` and `nodestartDef` objects can be restricted to the first (baseline) row.

The `robustnessTest` argument is something that can be explored only if a series of neighboring networks have been generated. Neighboring networks can be produced using the `exploreEdges` function. A future tutorial will be generated to explore why and how to test the robustness of the network.

For the chosen combination of screens, the default behavior of PSoup is to simulate every combination of scenarios from each screen. However, if the user wants to run a defined set of simulations, this is possible by setting the following argument; `combinatorial = FALSE`. In this case, it is necessary for any screen that is not only expressing a single condition to have the same number of rows as the same index will be used to cycle through all screens. Therefore, each row in an explored screen will only be simulated agains the equivalent rows in all other explored screens. 

We can start by exploring the behaviour of the modifying genotype (modifier) values according to the screen that we automatically generated above.

```{r eval = FALSE}
setupSims(folder, nodestartBaseline = T)
load(paste0(folder, "/genotypeDef_Sims.RData"))
```

```{r echo = FALSE}
load(paste0(folder2, "/genotypeDef_Sims.RData"))
```

Lets quickly inspect the outcome of one of these simulations:

```{r, out.width="90%", dpi=300, fig.align = 'center'}
fastPlot(output$screen[[6]])
```

Next we can explore the influence of the starting node values in isolation.

```{r eval = FALSE}
setupSims(folder, genotypeBaseline = T)
load(paste0(folder, "/nodestartDef_Sims.RData"))
```

```{r echo = FALSE}
load(paste0(folder2, "/nodestartDef_Sims.RData"))
```

Lets quickly inspect the outcome of one of these simulations:

```{r, out.width="90%", dpi=300, fig.align = 'center'}
fastPlot(output$screen[[2]])
```

As you can see in the above figure, even if the starting values of the system are different to that of the baseline, if the modifier values are held at baseline the system stabilised to the baseline condition.

If we want to explore the effects of providing an exogenous supply of resources in a baseline wildtype condition, we can do the following.

```{r eval = FALSE}
setupSims(folder, exogenousSupply = T, genotypeBaseline = T, nodestartBaseline = T)
load(paste0(folder, "/exogenousDef_Sims.RData"))
```

```{r echo = FALSE}
load(paste0(folder2, "/exogenousDef_Sims.RData"))
```

Lets quickly inspect the outcome of one of these simulations:

```{r, out.width="90%", dpi=300, fig.align = 'center'}
fastPlot(output$screen[[2]])
```

The final screen condition is that of taking prior distributions of the modifiers, here we are keeping all other possibilities as baseline.

```{r eval = FALSE}
setupSims(folder, priorScreen = T, nodestartBaseline = T)
load(paste0(folder, "/priorDef_Sims.RData"))
```

```{r echo = FALSE}
load(paste0(folder2, "/priorDef_Sims.RData"))
```

Lets quickly inspect the outcome of one of these simulations:

```{r, out.width="90%", dpi=300, fig.align = 'center'}
fastPlot(output$screen[[2]])
```

While only screens involving a single dimension have been demonstrated in this tutorial, it is possible to explore multiple dimensions at once. Use the arguments of the `setupSims` function to specify which objects in your model folder that you want to explore. `setupSims` will run every combination of conditions in each of the objects indicated.
<!-- modifierPriorScreen(folder, n = 1000) -->
<!-- load(paste0(folder, "/priorDef.RData")) -->
<!-- priorDef -->

<!-- boxplot(log(priorDef)) -->


<!-- priorSims <- setupSims(folder, report = T, priorScreen = T, tmax = 100) -->
<!-- save(priorSims, file = paste0(folder, "/priorSims.RData")) -->
<!-- load(paste0(folder, "/priorSims.RData")) -->

<!-- fastPlot(priorSims$screen[[7]]) -->
<!-- unique(stabilityVector(priorSims)) -->

<!-- stableNodes <- finalStates(priorSims$screen) -->

<!-- boxplot(log(stableNodes), cex = 0.5, cex.axis = 0.5) -->
<!-- abline(0,0, col = "red") -->

<!-- plot(stableNodes$FB_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$FB_R, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$SL_R, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$SL_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->
<!-- plot(stableNodes$Perception_P, stableNodes$InhibitGrowth_B, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->

<!-- priorDef[which(stableNodes$SL_P == max(stableNodes$SL_P)), ] -->

<!-- plot(stableNodes$SL_R, stableNodes$SL_S, pch = 16, cex = 0.5, col = rgb(0,0,0,0.5)) -->

<!-- decreasingBO <- stableNodes[order(stableNodes$InhibitGrowth_B), ] -->

<!-- plot.ts(decreasingBO[, c("InhibitGrowth_B", "FB_P", "FB_R", "SL_P", "SL_R", "Perception_P")]) -->



